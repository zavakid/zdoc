site: 
{"related_posts"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2011/11/17/tokyo-tyrant-vs-redis>, <Post: /2011/07/30/unix-io-model>, <Post: /2012/07/31/resolved_ubuntu_hosts>, <Post: /2011/10/22/virtual-memory>, <Post: /2011/10/16/why_virtual_memory>, <Post: /2012/05/05/using_terminator>], "safe"=>false, "auto"=>false, "server"=>false, "server_port"=>4000, "source"=>"/home/soz/shell/ruby/zava-doc", "destination"=>"/home/soz/shell/ruby/zava-doc/_site", "plugins"=>"/home/soz/shell/ruby/zava-doc/_plugins", "future"=>true, "lsi"=>true, "pygments"=>true, "markdown"=>"maruku", "permalink"=>"/:year/:month/:day/:title/", "markdown_ext"=>"markdown,mkd,mkdn,md", "textile_ext"=>"textile", "maruku"=>{"use_tex"=>false, "use_divs"=>false, "png_engine"=>"blahtex", "png_dir"=>"images/latex", "png_url"=>"/images/latex"}, "rdiscount"=>{"extensions"=>[]}, "redcarpet"=>{"extensions"=>[]}, "kramdown"=>{"auto_ids"=>true, "footnote_nr"=>1, "entity_output"=>"as_char", "toc_levels"=>"1..6", "use_coderay"=>false, "coderay"=>{"coderay_wrap"=>"div", "coderay_line_numbers"=>"inline", "coderay_line_number_start"=>1, "coderay_tab_width"=>4, "coderay_bold_every"=>10, "coderay_css"=>"style"}}, "name"=>"说者无意", "description"=>"代码如诗，生活如画", "assets_path"=>"/themes/foundation", "time"=>2012-10-31 19:19:55 +0800, "posts"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>, <Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2012/07/31/resolved_ubuntu_hosts>, <Post: /2012/05/05/using_terminator>, <Post: /2011/11/17/tokyo-tyrant-vs-redis>, <Post: /2011/10/22/virtual-memory>, <Post: /2011/10/16/why_virtual_memory>, <Post: /2011/07/30/unix-io-model>], "pages"=>[#<Jekyll:Page @name="bytecode.md">, #<Jekyll:Page @name="index.html">, #<Jekyll:Page @name="categories.html">], "html_pages"=>[#<Jekyll:Page @name="bytecode.md">, #<Jekyll:Page @name="index.html">, #<Jekyll:Page @name="categories.html">], "categories"=>{"linux"=>[<Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2012/07/31/resolved_ubuntu_hosts>, <Post: /2011/10/22/virtual-memory>, <Post: /2011/10/16/why_virtual_memory>, <Post: /2011/07/30/unix-io-model>], "nosql"=>[<Post: /2011/11/17/tokyo-tyrant-vs-redis>], "efficiency"=>[<Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2012/07/31/resolved_ubuntu_hosts>, <Post: /2012/05/05/using_terminator>], "java"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>], "concurrent"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>]}, "tags"=>{"IO复用"=>[<Post: /2011/07/30/unix-io-model>], "IO模型"=>[<Post: /2011/07/30/unix-io-model>], "Java"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>, <Post: /2011/07/30/unix-io-model>], "NIO"=>[<Post: /2011/07/30/unix-io-model>], "同步IO"=>[<Post: /2011/07/30/unix-io-model>], "异步IO"=>[<Post: /2011/07/30/unix-io-model>], "阻塞IO"=>[<Post: /2011/07/30/unix-io-model>], "非阻塞IO"=>[<Post: /2011/07/30/unix-io-model>], "cache"=>[<Post: /2011/10/16/why_virtual_memory>], "Linux"=>[<Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2012/07/31/resolved_ubuntu_hosts>, <Post: /2012/05/05/using_terminator>, <Post: /2011/11/17/tokyo-tyrant-vs-redis>, <Post: /2011/10/22/virtual-memory>, <Post: /2011/10/16/why_virtual_memory>], "为什么有虚拟内存"=>[<Post: /2011/10/16/why_virtual_memory>], "内存"=>[<Post: /2011/10/16/why_virtual_memory>], "存储器层次结构"=>[<Post: /2011/10/16/why_virtual_memory>], "虚拟内存"=>[<Post: /2011/10/22/virtual-memory>, <Post: /2011/10/16/why_virtual_memory>], "物理内存"=>[<Post: /2011/10/22/virtual-memory>], "物理页面"=>[<Post: /2011/10/22/virtual-memory>], "虚拟页面"=>[<Post: /2011/10/22/virtual-memory>], "nosql"=>[<Post: /2011/11/17/tokyo-tyrant-vs-redis>], "redis"=>[<Post: /2011/11/17/tokyo-tyrant-vs-redis>], "tokyo tyrant"=>[<Post: /2011/11/17/tokyo-tyrant-vs-redis>], "tt server"=>[<Post: /2011/11/17/tokyo-tyrant-vs-redis>], "life"=>[<Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2012/05/05/using_terminator>], "terminator"=>[<Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2012/05/05/using_terminator>], "Ubuntu"=>[<Post: /2012/10/09/terminator_in_ubuntu_bugfix>, <Post: /2012/07/31/resolved_ubuntu_hosts>, <Post: /2012/05/05/using_terminator>], "效率"=>[<Post: /2012/05/05/using_terminator>], "hosts.ac"=>[<Post: /2012/07/31/resolved_ubuntu_hosts>], "hosts被重置"=>[<Post: /2012/07/31/resolved_ubuntu_hosts>], "AbstractQueuedSynchronizer"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>], "aqs"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>], "concurrent"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>], "并发"=>[<Post: /2012/10/12/aqs_2>, <Post: /2012/10/12/aqs_1>]}}

page:
{"layout"=>"dummy", "title"=>"Java并发同步器AQS(AbstractQueuedSynchronizer)学习笔记(1)", "categories"=>["java", "concurrent"], "tags"=>["AbstractQueuedSynchronizer", "aqs", "concurrent", "Java", "并发"], "url"=>"/2012/10/12/aqs_1/", "date"=>2012-10-12 00:00:00 +0800, "id"=>"/2012/10/12/aqs_1", "next"=><Post: /2012/10/12/aqs_2>, "previous"=><Post: /2012/10/09/terminator_in_ubuntu_bugfix>, "content"=>"<code>Java</code>中的并发包，是在Java代码中并发程序的热门话题。如果我们去读<code>concurrent</code>包的源码时，会发现其真正的核心是 <code>AbstractQueuedSynchronizer</code> ， 简称 AQS 框架 , 而 Doug Lea 大神正是此包的作者。\n\n\n\n之前也看过一遍 <code>AbstractQueuedSynchronize</code>，但印象不深，只有依稀的印象。这次重新学习一遍，并整理出笔记，希望对自己或者是别人有用。当然了，笔者也是浅显的过一遍，很多细节也并不是完全理解。\n\n\n\n建议读者先看这个系列的文章：<a href=\"http://whitesock.iteye.com/blog/1336920\">Inside AbstractQueuedSynchronizer</a>，之后再继续本篇。\n\n\n\n首先，<code>AQS</code>会对进行 acquire 而被阻塞的线程进行管理，说是管理，其实就是内部维护了一个<code>FIFO队列</code>，这个队列是一个双向链表。链头可以理解为是一个空的节点，除了链头以外，每个节点内部都持有着一个线程，同时，有着两个重要的字段：<code>waitStatus</code> 和 <code>nextWaiter</code>。<code>nextWaiter</code>一般是作用与在使用<code>Condition</code>时的队列。而<code>waitStatus</code>则有以下几个字段：\n\n\n\n<ul>\n<li><strong>SIGNAL</strong> 表示下一个节点应该被唤醒。为什么是下一个节点？因为刚刚说了，这个<code>FIFO队列</code>，链头都是一个空的节点，但此节点的 <code>waitStatus</code> 正好就表示了要对下一节点做的事情</li>\n<li><strong>CANCELLED</strong> 表示此节点持有的线程被中断，或者该线程为<code>null</code>了。节点只能是暂时停留在此状态，因为在线程进入AQS时，线程会找机会整理链表，包括删除<code>CANCELLED</code>状态的节点。</li>\n<li><strong>CONDITION</strong> 表示此节点是在另一个队列中 —— condition队列中。比如我们使用的<code>ReentrantLock.newCondition()</code>获得<code>Condition</code>对象进行<code>await</code>时，在AQS内部所产生的节点。</li>\n<li><strong>PROPAGATE</strong> 顾名思义，传播。这点比较难理解，需要仔细推敲。因为此状态是为共享同步器使用的。加入此状态，可以避免无谓的线程 <code>park</code> 和 <code>unpark</code>。按照我对代码的理解，这是对多个线程并发获取共享同步器(比如<code>acquireShared</code>)所进行的优化，至少有3个线程并发，但想要优化效果明显的话，可能需要几十个线程并发的获取共享同步器(比如<code>acquireShared</code>)，如果在并发量非常大的时候，对系统的吞吐量的作用应该不少。</li>\n</ul>\n\n<code>AbstractQueuedSynchronizer</code>内置一个<code>state</code>字段，用来表示某种意义——当<code>ReentrantLock</code>使用AQS的时候，<code>state</code>被用来表示锁被重入的次数；当'Semaphore'使用AQS的时候，<code>state</code>则被用来表示当前还有多少信号量可被获取。\n\n\n\n<code>AbstractQueuedSynchronizer</code> 支持两种模式，分别是独占式和共享式。两者进行获取和释放动作的思路都是差不多的。\n\n\n\n获取同步器的流程如下：\n\n\n\n<pre><code>if(尝试获取成功){\n  return；\n}else{\n  加入等待队列;park自己\n}\n</code></pre>\n\n释放同步器的流程如下：\n\n\n\n<pre><code>if(尝试释放成功){\n  unpark等待队列中第一个节点\n}else{\n  return false\n}\n</code></pre>\n\n只要环绕着这两个思路去看<code>AQS</code>中的代码，相信应该可以明白其中的主要原理。\n\n\n"}

post:
{"layout"=>"post", "title"=>"Java并发同步器AQS(AbstractQueuedSynchronizer)学习笔记(2)", "categories"=>["java", "concurrent"], "tags"=>["AbstractQueuedSynchronizer", "aqs", "concurrent", "Java", "并发"], "url"=>"/2012/10/12/aqs_2/", "date"=>2012-10-12 00:00:00 +0800, "id"=>"/2012/10/12/aqs_2", "next"=>nil, "previous"=><Post: /2012/10/12/aqs_1>, "content"=>"学习了<code>AbstractQueuedSynchronizer</code> 之后(<code>Condition</code>没有在上文做笔记，当应该不难理解)，接下来笔者就尝试着分析在<code>JUC</code>包中的各个同步器，其语义是如何实现的。\n\n\n\n<h2>ReentrantLock</h2>\n\n内部类<code>Sync</code>继承了<code>AbstractQueuedSynchronizer</code>。<code>state</code>表示锁被重入的次数。因为其是独占锁，所以只实现了<code>tryRelease</code>，<code>isHeldExclusively</code>方法，而<code>tryAcquire</code>则交由子类基于公平和非公平的策略来实现。\n\n\n\n公平的<code>ReentrantLock</code>会在每次<code>tryAcquire</code>的时候，都老老实实让排在队列前面的线程优先拿锁。而非公平锁则是发现<code>state</code>为0后，就马上去尝试设置<code>state</code>，如果不能成功，才进入<code>AQS</code>内部的队列老老实实的排队。\n\n\n\n<h2>ReentrantReadWriteLock</h2>\n\n此类最为复杂。内部类<code>Sync</code>继承了<code>AbstractQueuedSynchronizer</code>，同时内部类<code>ReadLock</code>和<code>WriteLock</code>内部共享了<code>Sync</code>，<code>state</code>这个<code>int</code>被划分成两部分，高位16个bit表示共享读锁，低位16个bit表示独占写锁。\n\n\n\n大概的工作方式是：读锁使用<code>shared模式</code>，复写<code>tryAcquireShared</code>和<code>tryReleaseShared</code>；写锁使用独占锁，复写<code>tryAcquire</code>和<code>tryRelease</code>。当线程要求锁住写锁的时候，内部会检查<code>state</code>是否为0；如果不为0，则检查此时是写状态还是读状态；如果是写状态，则检查持有写锁的是否是自己；如果是的话，则进行锁重入。锁住读锁也是这个道理，只不过是使用的<code>shared</code>的锁模式而已。\n\n\n\n<h2>Semaphore</h2>\n\n使用<code>state</code>表示信号量。可以想象，使用是的<code>shared</code>模式。在<code>acquire</code>的时候，会去比较<code>state</code>来判断是否可以成功。\n\n\n\n需要注意的是此类如果使用不当，则可能会有线程被挂住的问题，测试代码可以参见这里：<a href=\"https://gist.github.com/3879133\">https://gist.github.com/3879133</a>。\n\n\n\n<h2>CountDownLatch</h2>\n\n与<code>Semaphore</code>一样，都是非常简单的使用了<code>state</code>。\n\n\n\n<h2>CyclicBarrier</h2>\n\n内部使用的是<code>ReentrantLock</code>，利用了<code>Condition</code>来唤醒栅栏前的线程。\n\n\n\n<h2>FutureTask</h2>\n\n使用<code>state</code>来表示任务的执行状态。代码也相对比较简单。值得注意的是，<code>FutureTask</code>对于任务执行抛出的异常，是会捕捉住的（在get的时候才会给抛给你），如果在编写任务时候没有<code>catch(Exception)</code>，而导致有异常漏过业务代码，则很有可能产生不可预知的问题。比如，在使用 <code>ScheduledExecutorService</code>分发定时任务之后，而又不关心返回结果的时候，就可能会出现问题。所以一般对自己的线程，也应该处理自己线程的异常，这也是最佳实践的原则。\n\n\n"}

{"layout"=>"dummy", "title"=>"Java并发同步器AQS(AbstractQueuedSynchronizer)学习笔记(1)", "categories"=>["java", "concurrent"], "tags"=>["AbstractQueuedSynchronizer", "aqs", "concurrent", "Java", "并发"], "url"=>"/2012/10/12/aqs_1/", "date"=>2012-10-12 00:00:00 +0800, "id"=>"/2012/10/12/aqs_1", "next"=><Post: /2012/10/12/aqs_2>, "previous"=><Post: /2012/10/09/terminator_in_ubuntu_bugfix>, "content"=>"<code>Java</code>中的并发包，是在Java代码中并发程序的热门话题。如果我们去读<code>concurrent</code>包的源码时，会发现其真正的核心是 <code>AbstractQueuedSynchronizer</code> ， 简称 AQS 框架 , 而 Doug Lea 大神正是此包的作者。\n\n\n\n之前也看过一遍 <code>AbstractQueuedSynchronize</code>，但印象不深，只有依稀的印象。这次重新学习一遍，并整理出笔记，希望对自己或者是别人有用。当然了，笔者也是浅显的过一遍，很多细节也并不是完全理解。\n\n\n\n建议读者先看这个系列的文章：<a href=\"http://whitesock.iteye.com/blog/1336920\">Inside AbstractQueuedSynchronizer</a>，之后再继续本篇。\n\n\n\n首先，<code>AQS</code>会对进行 acquire 而被阻塞的线程进行管理，说是管理，其实就是内部维护了一个<code>FIFO队列</code>，这个队列是一个双向链表。链头可以理解为是一个空的节点，除了链头以外，每个节点内部都持有着一个线程，同时，有着两个重要的字段：<code>waitStatus</code> 和 <code>nextWaiter</code>。<code>nextWaiter</code>一般是作用与在使用<code>Condition</code>时的队列。而<code>waitStatus</code>则有以下几个字段：\n\n\n\n<ul>\n<li><strong>SIGNAL</strong> 表示下一个节点应该被唤醒。为什么是下一个节点？因为刚刚说了，这个<code>FIFO队列</code>，链头都是一个空的节点，但此节点的 <code>waitStatus</code> 正好就表示了要对下一节点做的事情</li>\n<li><strong>CANCELLED</strong> 表示此节点持有的线程被中断，或者该线程为<code>null</code>了。节点只能是暂时停留在此状态，因为在线程进入AQS时，线程会找机会整理链表，包括删除<code>CANCELLED</code>状态的节点。</li>\n<li><strong>CONDITION</strong> 表示此节点是在另一个队列中 —— condition队列中。比如我们使用的<code>ReentrantLock.newCondition()</code>获得<code>Condition</code>对象进行<code>await</code>时，在AQS内部所产生的节点。</li>\n<li><strong>PROPAGATE</strong> 顾名思义，传播。这点比较难理解，需要仔细推敲。因为此状态是为共享同步器使用的。加入此状态，可以避免无谓的线程 <code>park</code> 和 <code>unpark</code>。按照我对代码的理解，这是对多个线程并发获取共享同步器(比如<code>acquireShared</code>)所进行的优化，至少有3个线程并发，但想要优化效果明显的话，可能需要几十个线程并发的获取共享同步器(比如<code>acquireShared</code>)，如果在并发量非常大的时候，对系统的吞吐量的作用应该不少。</li>\n</ul>\n\n<code>AbstractQueuedSynchronizer</code>内置一个<code>state</code>字段，用来表示某种意义——当<code>ReentrantLock</code>使用AQS的时候，<code>state</code>被用来表示锁被重入的次数；当'Semaphore'使用AQS的时候，<code>state</code>则被用来表示当前还有多少信号量可被获取。\n\n\n\n<code>AbstractQueuedSynchronizer</code> 支持两种模式，分别是独占式和共享式。两者进行获取和释放动作的思路都是差不多的。\n\n\n\n获取同步器的流程如下：\n\n\n\n<pre><code>if(尝试获取成功){\n  return；\n}else{\n  加入等待队列;park自己\n}\n</code></pre>\n\n释放同步器的流程如下：\n\n\n\n<pre><code>if(尝试释放成功){\n  unpark等待队列中第一个节点\n}else{\n  return false\n}\n</code></pre>\n\n只要环绕着这两个思路去看<code>AQS</code>中的代码，相信应该可以明白其中的主要原理。\n\n\n"}

{"layout"=>"post", "title"=>"terminator在ubuntu下有僵尸进程的解决", "categories"=>["linux", "efficiency"], "tags"=>["life", "Linux", "terminator", "Ubuntu"], "url"=>"/2012/10/09/terminator_in_ubuntu_bugfix/", "date"=>2012-10-09 00:00:00 +0800, "id"=>"/2012/10/09/terminator_in_ubuntu_bugfix", "next"=><Post: /2012/10/12/aqs_1>, "previous"=><Post: /2012/07/31/resolved_ubuntu_hosts>, "content"=>"之前用一篇文章介绍了一个非常好用的软件：<a href=\"http://www.zavakid.com/178\">terminator</a>。但在我使用了一段时间之后，发现每当我启动 terminator 的时候，都会有一个僵尸进程存在，于是搜索了一番，最后找到这个  <a href=\"https://bugs.launchpad.net/terminator/+bug/885606\">terminator 的 bug</a>。\n\n\n\n仔细查看一番，原来是路径找不到的path，按照连接中讨论的方案，修复也非常简单。\n\n\n\n<pre><code>cd /use/lib\nsudo ln -s libvte9 vte\n</code></pre>\n\n就是这么简单。\n\n\n"}
